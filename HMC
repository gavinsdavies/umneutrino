import numpy as np
import time

def U(x):
    x1, x2 = x
    return (1 - x1)**2 + 100 * (x2 - x1**2)**2

def grad_U(x):
    x1, x2 = x
    # Calculate the gradient for X1:  2(x1 - 1) - 400 x1 (x2 - x1^2)
    dU_dx1 = 2*(x1 - 1) - 400*x1*(x2 - x1**2)
    # Calculate the gradient for X2:  200 (x2 - x1^2)
    dU_dx2 = 200*(x2 - x1**2)
    return np.array([dU_dx1, dU_dx2])

# Leapfrog integration for Hamiltonian dynamics
def leapfrog(x, p, eps, L):
    x_new = x.copy()
    p_new = p - 0.5 * eps * grad_U(x_new)
    for _ in range(L):
        x_new += eps * p_new
        if _ != L - 1:
            p_new -= eps * grad_U(x_new)
    p_new -= 0.5 * eps * grad_U(x_new)
    return x_new, p_new

def H(x, p):
    return U(x) + 0.5 * np.sum(p**2)

def hmc_sampler(num_samples=100_000, eps=0.01, L=50):
    samples = np.zeros((num_samples, 2))
    x = np.array([1.0, 1.0])
    n_accept = 0
    # Hamiltonian Monte Carlo algorithm
    # Propose a sample and then decide whether to accept or not.
    for i in range(num_samples):
        p0 = np.random.randn(2)
        x_prop, p_prop = leapfrog(x, p0, eps, L)
        if np.random.rand() < np.exp(H(x, p0) - H(x_prop, p_prop)):
            x = x_prop
            n_accept += 1
        samples[i] = x

    return samples, n_accept / num_samples

if __name__ == "__main__":
    num_samples = 100_000
    eps = 0.01   # small step to handle sharp curvature
    L   = 50     # sample for each trajectory, can tune it for more accuracy

    start = time.time()
    samples, acc_rate = hmc_sampler(num_samples, eps, L)
    runtime = time.time() - start

    norm2 = np.sum(samples**2, axis=1)
    est = np.mean(norm2)

    print("=== Hamiltonian Monte Carlo ===")
    print(f"Acceptance rate:      {acc_rate:.3f}")
    print(f"Estimated E[x₁²+x₂²]: {est:.6f}")
    print(f"Runtime (s):          {runtime:.6f}")
